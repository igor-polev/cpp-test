Основным инструментом для вычисления адресов была выбрана библиотека libbitcoin-system, в которой бОльшая часть математики уже реализована. Далее, если иное не оговорено, упоминаемые функции и классы относятся к этой библиотеке.

Структура алгоритма.

1. Исходный текст (тестровый пример - bitcoin is awesome) конвертировался в секретный ключ функцией sha256_hash().

2. Полученным ключен инициализировались два экземпляра класса ec_private с пераметрами compressed = true и compressed = false, из которых получались адреса WIF методом encode().

3. Из экземпляров класса ec_private получались экземпляры класса btc_address через метод to_payment_address(). Класс btc_address наследовался от библиотечного класса payment_address с целью расширения функционала для получения адреса P2SH. 

4. Класс payment_address через метод encode() генерирует адрес P2PKH - сжатый или несжатый соответсственно исходным экземплярам класса ec_private.

5. В классе btc_address был реализован метод конвертаци скрипта P2PKH в скрипт P2SH. Скрипт P2PKH ролучался методом output_script() класса payment_address. Полученным скриптом P2SH инициализировался экземпляр класса btc_address (payment_address), из которого методом encode() получался P2SH адрес.

6. Адрес BECH32 генерировался непосредственно из открытого ключа, который получался из закрытого методом to_public() класса ec_private. Для этой цели от библиотечного класса ec_public наследовался класс btc_public, в котором и был реализован алгоритм получения BECH32, описанный кратко на https://en.bitcoin.it/wiki/Bech32:

    6.1. Открытый ключ дважды хешируется по схеме RIPEMD-160(SHA-256(public_key)). Реализовано в библиотечной функции bitcoin_short_hash().

    6.2. Результат п.6.1. преобразуется из формата 8-bit на символ в формат 5-bit на символ. Для этого был использован готовый алгоритм, реализованный на Phython. Он был переписан на C++ (см. файл btc_func.cpp).

    6.3. К результату п.6.2. добавляется префикс 0x00.

    6.4. Остаток алгоритма - префикс MainNet, добавление checksum и кодирование в символы BECH32 - выполнялись функцией encodeUsingOriginalConstant() библиотеки libbech32.
